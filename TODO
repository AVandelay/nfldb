Flexibility in nfldb.Query
--------------------------
The march toward an ORM continues. I am going to eat so much crow. But hot damn 
is it convenient.

OK, so there are two things that the current Query interface utterly fails at:

1) Sorting *only* works with respect to the results returned. For example, if 
   you're retrieving plays and want to sort them by, say, the start time of the 
   game, you're SOL. This should be changed so that you can sort by whatever 
   field you want---you just have to pay for it with a join. The *problem* is 
   that the join can't add results, otherwise things get funky. For example, 
   you shouldn't be able to sort a `game` by `passing_yds`. (Incidentally, this 
   would be an interesting aggregate query, but that's a bit too complex for me 
   at the moment.)

2) The various `as_{player,game,drive,play,play_player,aggregate}` methods are 
   very limited in that the only thing returned are the data corresponding to a 
   `player` or a `game` or a `play`, etc.. It would be better if these methods 
   were smarter and could fetch other data. For example, selecting plays would 
   join on the `game` and `drive` tables. Selecting `play_player` would join on 
   every other table (because they are the Atoms of nfldb). Selecting a `game` 
   would not join on any table. (The pattern here is that joins occur only when 
   the join does not add more rows to the result set.)

   This particular feature is useful mostly for performance reasons. As it 
   stands now, one can, say, retrieve `play` objects and access the 
   corresponding drive or game with `p.drive.game`, but of course, this runs a 
   query for each play.

Given our new fancy SQL generation code, it is actually trivial to discover 
which joins to do. The challenge is presenting this in a nice API.

I think that we could pretty easily add parameters to the `as_*` methods. For 
example, for `as_plays`, we'd add `fill_game=True` and `fill_drive=True`. This 
is nice because it doesn't let the user specify a join that will increase the 
result set.

But sorting is a different story. What happens if the user is selecting games 
and sorts by `play_player.passing_yds`? I guess we'd need a `GROUP BY` with 
aggregates over the joining tables. Yuck. That's just too complex and easy to 
get wrong.

Probably we should just present an error to the user if they try to sort by a 
field that requires a join that increases the result set. It's icky, but 
keeping the `sort` method generic as it is now is very nice.

We'd have to slightly amend the `sort` arguments though. Maybe allow triples? 
e.g., `('game', 'start_time', 'asc')` if selecting `as_plays`? Yes, I like 
that. It's unambiguous, clear and backwards compatible.

